<html>
  <head>
    <title>GLI: Make Awesome Command-Line Applicatison the Easy Way</title>
    <link href='http://fonts.googleapis.com/css?family=Karla:400,700,400italic,700italic|Alegreya' rel='stylesheet' type='text/css'>
    <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
    <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js" type="text/javascript"></script>
    <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushRuby.js" type="text/javascript"></script>
    <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushBash.js" type="text/javascript"></script>
    <link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeMidnight.css" rel="stylesheet" type="text/css" />
    <style>
      body { 
        margin: 0 auto;
        width: 768px;
        background: url(images/bg.png);
      }
      #content {
        background-color: white;
        padding: 16px;
        margin-top: -128px;
        -webkit-border-radius: 16px;
        -moz-border-radius: 16px;
        border-radius: 16px;
      }
      h1, h2, h3, h4, h5, h6, p, li {
        font-family: 'Karla', sans-serif;
      }
      h1, h2, h3, h4, h5, h6 {
        font-weight: bold;
      }
      h1#main-title {
        display: none;
      }
      h2#sub-title {
        text-align: center;
      }
      h2 {
        font-size: 32px;
      }

      h3 {
        font-size: 24px;
        background: #ddd;
        border: solid thin #aaa;
        -webkit-border-radius: 8px;
        -moz-border-radius: 8px;
        border-radius: 8px;

        padding: 8px;
      }
      h4 {
        font-size: 22px;
      }
      p, li {
        font-family: 'Karla', sans-serif;
        font-size: 16px;
        line-height: 28px;
        text-align: justify;
      }
      p code, li code {
        font-family: Monaco, courier, monospace;
        font-weight: bold;
        font-size: 14px;
        border: solid thin black;
        -webkit-border-radius: 4px;
        -moz-border-radius: 4px;
        border-radius: 4px;
        padding: 2px;
        padding-left: 4px;
        padding-right: 4px;
        background: #ddd;

        overflow-x: scroll;
        white-space: nowrap;
      }
      ul {
        list-style-position: inside;
        margin-right: 32px;
        margin-top: 0;
        margin-bottom: 0;
      }
      li {
        font-size: 90%;
      }
      div.syntaxhighlighter {
        margin: 0px;
        margin-left: -16px;
        width: 736px;
        padding: 16px;
      }
      .note {
        font-style: italic;
        font-size: 14px;
      }
      .subsection p { 
        margin-left: 32px;
        margin-right: 32px;
      }
      .sidebar {
        color: #222;
        background-color: #eee;
        border: solid thin #aaa;
        -webkit-border-radius: 16px;
        -moz-border-radius: 16px;
        border-radius: 16px;
        margin: 8px;
        box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.60);
        -moz-box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.60);
        -webkit-box-shadow: 8px 8px 16px rgba(0, 0, 0, 0.60);
      }
      .sidebar p code {
        color: black;
        background: white;
      }
      .sidebar h4 {
        font-family: 'Alegreya', serif;
        font-weight: bold;
        margin-left: 32px;
        margin-right: 32px;
        border-bottom: solid thin;
        padding: 0px;
      }
      .sidebar p, .sidebar li {
        font-family: 'Alegreya', serif;
      }
      .sidebar div.syntaxhighlighter {
        margin-left: 0px;
        width: 687px;
      }

    </style>
  </head>
  <body>
    <img src="images/logo.png" />
    <div id="content">
      <h1 id="main-title">GLI</h1>
      <h2 id="sub-title">The easy way to make command-suite CLI apps</h2>
      <p>
      GLI is the easiest way to make a CLI app that takes commands, in a vein similar to
      <code>git</code> or <code>gem</code> (GLI stands for "Git-Like Interface").  GLI uses a 
      simple DSL, but retains all the power you'd expect from the built-int <code>OptionParser</code>.
      <span class="note">If you're looking to make a vanilla CLI app that doesn't need command support, 
      be sure to check out <a href="http://davetron5000.github.com/methadone">Methadone</a>, which gives you all the power
      of <code>OptionParser</code>, but none of the verbosity</span>.
      </p>
      <p>
      Here's a simple todo list application:
      </p>
      <pre class="brush: ruby">
      #!/usr/bin/env ruby
      require 'gli'
      require 'hacer'

      include GLI::App

      program_desc 'A simple todo list'

      flag [:t,:tasklist], :default_value => File.join(ENV['HOME'],'.todolist')

      pre do |global_options,command,options,args|
        $todo_list = Hacer::Todolist.new(global_options[:tasklist])
      end

      command :add do |c|
        c.action do |global_options,options,args|
          $todo_list.create(args)
        end
      end

      command :list do |c|
        c.action do 
          $todo_list.list.each do |todo|
            printf("%5d - %s\n",todo.todo_id,todo.text)
          end
        end
      end

      command :done do |c|
        c.action do |global_options,options,args|
          id = args.shift.to_i
          $todo_list.list.each do |todo|
            $todo_list.complete(todo) if todo.todo_id == id
          end
        end
      end

      exit run(ARGV)
      </pre>
      <p>
      We can now use our app like so:
      </p>
      <pre class="brush: bash">
      $ todo help
      NAME
          todo - A simple todo list

      SYNOPSIS
          todo [global options] command [command options] [arguments...]

      GLOBAL OPTIONS
          --help             - Show this message
          -t, --tasklist=arg - (default: /Users/davec/.todolist)

      COMMANDS
          add  - 
          done - 
          help - Shows a list of commands or help for one command
          list - 

      $ todo add "Take out trash"
      $ todo add "Rake leaves"
      $ todo add "Clean Kitchen"
      $ todo list
          0 - ["Take out trash"]
          1 - ["Rake leaves"]
          2 - ["Clean Kitchen"]
      $ todo done 1
      $ todo list
          0 - ["Take out trash"]
          2 - ["Clean Kitchen"]
      </pre>
      <p>
      We can make our app so much better.  For a longer demo, or just a quick reference, check out the <a href="todo.html">annotated source</a> for a much more sophisticated application.  Meanwhile, let's tour some of the features.
      </p>
      <h3>Commands</h3>
      <div class="subsection">
        <p>
        The entire UI of your app is commands, and you can create them with the <code>command</code> method.  It takes a block, which is given a <code>GLI::Command</code> instance.  You can call DSL methods on this to describe how your command works.  The thing you are required to do is call the <code>action</code> methods, which takes a block.  <strong>This</strong> block is executed when the user executes the command on the command-line.  To access the command-line options and arguments, the block we give
        to action can accept parameters.  We'll see those in a little bit.
        </p>
        <p>
        One thing we didn't see is how to document our command.  This is done Rake-stye via the methods <code>desc</code> and <code>long_desc</code>.  <code>desc</code> is
        short one-line description that shows up in the main help, while <code>long_desc</code> is a longer description, possibly multi-paragraph, that shows up in the help
        for this command (e.g. when the user runs <code>todo help list</code>).  Let's add documentation to our <code>list</code> command.
        <pre class="brush: ruby">
        desc 'List tasks'
        long_desc 'Lists all tasks that have yet to be completed by the user.

        Each task has an id, which you can use to complete it using the "done" command.'
        command :list do |c|
          c.action do 
            $todo_list.list.each do |todo|
              printf("%5d - %s\n",todo.todo_id,todo.text)
            end
          end
        end
        </pre>
      </div>
      <h3>Command-Line Options</h3>
      <div class="subsection">
        <p>
        Command-line options for a command-suite come in two forms:
        </p>
        <ul>
          <li><strong>Global Options</strong> come before the command on the command-line, and generally affect every command.  In our simple todo app, the option
          <code>-t</code> (or its long-form equivalent <code>--tasklist</code>) tells <strong>all</strong> commands where tro find the task list.</li>
          <li><strong>Command Options</strong> come after the command on the command-line, and are specific to the command itself.  For example, we might have a switch
          that tells <code>list</code> to list completed tasks as well as outstanding tasks.</li>
        </ul>
        <p>
        In GLI, global options are specified outside of any command block (much like we specified <code>-t</code> with <code>flag [:t,:tasklist]</code>.  Command options
        are specified inside a <code>command</code> block.  Let's add a global switch for verbosity, and a command option to <code>list</code> to show 
        completed tasks as well. Options can be documented in the same way, using <code>desc</code>.
        </p>
        <pre class="brush: ruby">
        desc 'Be verbose'
        switch [:v,:verbose]

        desc 'List tasks'
        long_desc 'Lists all tasks that have yet to be completed by the user.

        Each task has an id, which you can use to complete it using the "done" command.'
        command :list do |c|
          c.desc 'Show completed tasks as well as incomplete tasks'
          c.switch [:a,:all]

          c.action do |global_options,options,args|
            show = options[:all] ? :all : :incomplete
            $todo_list.list(show).each do |todo|
              printf("%5d - %s\n",todo.todo_id,todo.text)
            end
          end
        end
        </pre>
        <p>
        Notice that we changed the parameters to our <code>action</code> block.  It now gets a <code>Hash</code> of the global options, a 
        <code>Hash</code> of the command options, and the unparsed arguments as an <code>Array</code>.  We reach into <code>options</code>
        to see if <code>--all</code> (or <code>-a</code>) was specified, and show all tasks if so.
        </p>
        <div class="sidebar">
          <h4>What's a "switch" and what's a "flag"?</h4>
          <p>
          GLI differentates options that take arguments from ones that don't.  Options that don't merely <em>switch</em> something on or
          off, and are called <em>switches</em>.  Options that take an argument are called <em>flags</em>.  The global option
          <code>tasklist</code> is a flag.  As such, it can have a default value, which we specified by using the <code>:default_value</code>
          option.
          </p>
          <p>
          <code>flag</code> can take other options as well.  It can take <code>:type</code>, which is a class for type conversion, as well
          as <code>:must_match</code> which can be a regular expression, <code>Array</code>, or <code>Hash</code>:
          </p>
          <ul>
            <li>If a <code>Regexp</code>, the argument on the command-line must match the regexp, or the app will exit nonzero with an appropriate
            error message</li>
            <li>If an <code>Array</code>, the argument must be a member of the array, or the app will exit nonzero with an appropriate error message</li>
            <li>If a <code>Hash</code>, the argument must be a <em>key</em> of the <code>Hash</code>, or the app will exit nonzero with an appropriate error message.
            If the value is a key, the <em>value</em> of that key of the <code>Hash</code> is passed in as the flag's value.</li>
          </ul>
          <p>
          If this sounds like <code>OptionParser</code>, that's because it is: GLI uses it under the covers to parse the command-line.
          </p>


        </div>
        </div>
        <div class="subsection">
        <div class="subsection">
        <h3>Error Handling</h3>
        <p>
        Essentially, you don't need to do anything special; just allow exceptions to bubble up.  The exception's message will
        be shown to the user, and ther backtrace will be surpressed.  If you need to exit the program with an error message, you
        can certainly raise an exception, but you can also call either <code>exit_now!</code> or <code>help_now!</code>.
        The former exits with the message, while the latter also shows the command-line help.  Let's add in some checks
        in our <code>done</code> command to make sure that the id is passed and that it's an id in our task list.
        </p>
        <pre class="brush: ruby">
        command :done do |c|
          c.action do |global_options,options,args|
            help_now!('id is required') if args.empty
            todo = $todo_list.list.select { |todo| todo.todo_id == id }.first
            exit_now!("No todo with id #{id}") if todo.nil?
            $todo_list.complete(todo)
          end
        end
        </pre>
        <div class="sidebar">
        <h4>What if I <strong>want</strong> the backtrace?</h4>
        <p>
        When developing, it can be handy to see the backtrace of errors that cause your app to 
        exit.  To show them, set the environment variable <code>GLI_DEBUG</code> when calling your app, e.g.
        <code>GLI_DEBUG=true todo add 'some new task'</code>.
        </p>
        </div>
        <!-- left off-->
        </div>
        <h3>Pre- and Post-Hooks</h3>
        <p>
        You may have noticed the call to <code>pre</code> in our simple app.  This is a block of code called <em>after</em> the command-line
        has been successfully parsed, but <em>before</em> the command is executed.  It has access to the global and command-specific options, as well
        as the command itself, and the unparsed arguments.  
        </p>
        <p>
        We used it to read our todo list so that each command has access to it.  We set this in a global variable.  You might not like this,
        and you could, alternatively, set it inside the <code>global_options</code> hash:
        </p>
        <pre class="brush: ruby">
        pre do |global_options,command,options,args|
          # Replace the string with the actual list object
          global_options[:taslist] = Hacer::Todolist.new(global_options[:tasklist])
        end

        command :add do |c|
          c.action do |global_options,options,args|
            # Now, we can read it directly
            global_options[:tasklist].create(args)
          end
        end
        </pre>
        <p>
        If we had any cleanup to do, that could go in a <code>post</code> block:
        </p>
        <pre class="brush: ruby">
        post do |global_options,command,options,args|
          global_options[:taslist].save_to_disk!
        end
        </pre>
        <p>
        This block is only called if there were no errors.
        </p>
        <p>
        You can also use an <em>around</em> hook, which inverts the relationship and makes it easier to manage global
        setup for certain types of resources.  For example, if you wanted to have a file open during the command execution:
        </p>
        <pre class="brush: ruby">
        around do |global_options,command,options,args,code|
          File.open(global_options[:filename]) do |file|
            options[:file] = file
            code.call
          end
        end
        </pre>
        <p>
        This won't stop the pre/post hooks, so you can use all three if it makes the most sense for your app.
        </p>
        <p>
        You can also configure how error handling is done by declaring an <code>error</code>
        block.  The block you give to <code>error</code> doesn't have access to any of the parsed options
        or arguments (since the error could happen at any time during the lifecycle of your app).  If the block
        evaluates to true, GLI's normal error handling will occur.  If it evaluates to false, GLI will not do anything.
        </p>
        <div class="sidebar">
          <h4>Could the pre block be done via type-conversion?</h4>
          <p>
          If you know <code>OptionParser</code>, you know that it has a configurable type-conversion system.  GLI uses this system, so you could eliminate
          the <code>pre</code> block by type-converting the value of the <code>--tasklist</code> flag.  GLI's DSL has a method named
          <code>accept</code> that works just like the one in <code>OptionParser</code>:
          </p>
          <pre class="brush: ruby">
          accept(Hacer::Todolist) do |string|
            Hacher::Todolist.new(string)
          end

          flag [:t,:tasklist], :type => Hacer::Todolist,
                               :default_value => File.join(ENV['HOME'],'.todolist')
          </pre>
          <p>
          Now, the tasklist is set up during type conversion.  
          </p>
        </div>
      </div>
      <div class="subsection">
        <h3>Bootstrapping</h3>
        <p>
        In addition to the DSL and other helper methods, GLI is bundled with a command-line app, <code>gli</code>,
        that you can use to bootstrap your application.  By bootstrapping your app this way, you get, in seconds:
        </p>
        <ul>
          <li>A basic project structure</li>
          <li>An outline of your executable</li>
          <li>Gemfile and gemspec</li>
          <li>Scaffold for unit tests</li>
          <li>Scaffold for Aruba-and-Cucumber-powered integration tests to make testing your app a snap</li>
          <li>Rakefile to tie it all together</li>
        </ul>
        <p>
        <code>gli</code> has a command, <code>init</code> that takes the name of your app as an argument, followed by a list of commands your app will have (don't worry, you can easily add more using the methods and techniques we've already discussed):
        </p>
        <pre class="brush: shell">
        $ gli init todo add list complete
        $ cd todo
        $ bundle exec bin/todo help
        NAME
            todo - A simple todo list

        SYNOPSIS
            todo [global options] command [command options] [arguments...]

        GLOBAL OPTIONS
            --help             - Show this message
            -t, --tasklist=arg - (default: /Users/davec/.todolist)

        COMMANDS
            add  - 
            done - 
            help - Shows a list of commands or help for one command
            list - 
        $ rake test
        Run options: 

        # Running tests:

        .

        Finished tests in 0.151210s, 112.4264 tests/s, 218.2395 assertions/s.

        1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
        $ rake cucumber
        .

        1 scenarios (3 passed)
        3 steps (3 passed)
        0m0.049s
        </pre>
        <p>
        All you need to do is fill in your logic!
        </p>
        <div class="sidebar">
          <h4>Why do I need <code>bundle exec</code>?</h4>
          <p>
          GLI assumes your app distributes with RubyGems.  In that case, you don't need your <code>bin</code> file to 
          futz with the load path; RubyGems will set everything up after installation.  As such, in development, you can't
          just run your app directly, because your <code>lib/</code> directory will <strong>not</strong> be in the load
          path.  You could certainly do <code>RUBYLIB=lib bin/todo help</code>, but it's a bit easier and cleaner
          to use bundler.
          </p>
        </div>
      </div>
      <div class="subsection">
        <h3>How can I learn more?</h3>
        <p>
        There are three places to dig deeper into GLI:
        </p>
        <ul>
          <li><a href="todo.html">A code walkthrough</a> of a more sophisticated app that has subcommands</li>
          <li><a href="http://www.github.com/davetron5000/gli/wiki">The Wiki</a></li>
          <li><a href="rdoc/index.html">API Documentation</a></li>
        </ul>
        <p>
        Of course, <a href="http://www.github.com/davetron5000/gli">the source code</a> is also available.
        </p>
      </div>
    </div>
    <script>
      SyntaxHighlighter.defaults['gutter'] = false;
      SyntaxHighlighter.defaults['toolbar'] = false;

      SyntaxHighlighter.all();
    </script>
  </body>
</html>
